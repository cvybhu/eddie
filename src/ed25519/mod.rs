#![allow(non_camel_case_types)]
use super::bignum_u512::u512;
use super::u256_mod::u256mod;
/*
    Module implementing Elliptic curve Ed25519

    This curve has equation -(x^2) + y^2 = 1 + d * x^2 * y^2
    where d = -121665 / 121666
    All arithmetic operations on x, y are calculated modulo 2^255 - 19

*/

// TWO_TO_255_MINUS_19 == 2^255 - 19
// This is the prime number modulo which coordinates are calculated on the Ed25519 curve
pub const TWO_TO_255_MINUS_19: u512 = u512 { data: [18446744073709551597, 18446744073709551615, 18446744073709551615, 9223372036854775807, 0, 0, 0, 0] };


// Order of the main subgroup generated by the generator G = (x, 4/5)
// l = 2^252 + 27742317777372353535851937790883648493
// In total there are 8*PRIME_GROUP_ORDER points on the curve
pub const PRIME_GROUP_ORDER: u512 = u512 { data: [6346243789798364141, 1503914060200516822, 0, 1152921504606846976, 0, 0, 0, 0] };


// Order of the whole curve group - this is how many points are on the curve
// This equals 8 * PRIME_GROUP_ORDER
pub const CURVE_GROUP_ORDER: u512 = u512 { data: [13876462170967809896, 12031312481604134578, 0, 9223372036854775808, 0, 0, 0, 0] };


// unsigned 256-bit integer with all operations done modulo 2^255 - 19 automatically
pub type u256mod25519 = u256mod<moduluses::Modulus25519>;

// unsigned 256-bit integer with all operations done modulo PRIME_GROUP_ORDER automatically
pub type u256modPrimeOrder = u256mod<moduluses::ModulusPrimeOrder>;

// unsigned 256-bit integer with all operations done modulo CURVE_GROUP_ORDER automatically
pub type u256modCurveOrder = u256mod<moduluses::ModulusCurveOrder>;

mod moduluses; // defines Modulus25519, ModulusPrimeOrder, ModulusCurveOrder


// The constant d = 121665 / 121666
pub const CURVE_D_CONSTANT: u256mod25519 = u256mod { value: u512 { data: [8496970652267935907, 31536524315187371, 10144147576115030168, 5909686906226998899, 0, 0, 0, 0] },
                                                          this_is_stupid_why: std::marker::PhantomData };


// Curve point is expressed in projective coordinates
// curve_x = x/z   curve_y = y/z
// This allows to avoid modulo inverse during point addition
#[derive(Clone, Copy, Debug)]
pub struct CurvePoint {
    x: u256mod25519,
    y: u256mod25519,
    z: u256mod25519
}

impl CurvePoint {
    // For any point P:  (identity + P == P) and (P + identity == P)
    pub fn identity() -> CurvePoint {
        return CurvePoint { x: u256mod25519::zero(), y: u256mod25519::one(), z: u256mod25519::one() };
    }


    // Returns CurvePoint with given y coordinate and matching x 
    // From two possible x the even one is chosen (least significant bit set to 0, x.value % 2 == 0)
    pub fn from_y_coordinate(y_coord: u256mod25519) -> Option<CurvePoint> {
        let y_sqared = &y_coord * &y_coord;
        let x_squared = (y_sqared - u256mod25519::one()) / 
                        (CURVE_D_CONSTANT * y_sqared + u256mod25519::one());

        let mut matching_x = match sqrt_mod_25519::sqare_root(x_squared) {
                                Some(sqare_root) => sqare_root,
                                None => return None
                             };

        if matching_x.to_u512().get_bit(0) == true {
            matching_x = -matching_x;
        }

        assert_eq!(matching_x.to_u512().get_bit(0), false);

        assert!(CurvePoint::is_on_curve(&matching_x, &y_coord, &u256mod25519::one()));

        let result = CurvePoint { x: matching_x, y: y_coord, z: u256mod25519::one() };

        return Some(result);
    }

    pub fn get_x(&self) -> u256mod25519 {
        return &self.x / &self.z;
    }

    pub fn get_y(&self) -> u256mod25519 {
        return &self.y / &self.z;
    }

    pub fn is_on_curve(x: &u256mod25519, y: &u256mod25519, z: &u256mod25519) -> bool {
        let x_sqared: u256mod25519 = x * x;
        let y_sqared: u256mod25519 = y * y;
        let z_sqared: u256mod25519 = z * z;

        return (y_sqared - x_sqared) * z_sqared == z_sqared * z_sqared + CURVE_D_CONSTANT * x_sqared * y_sqared;
    }

    pub fn assert_on_curve(&self) {
        assert!(CurvePoint::is_on_curve(&self.x, &self.y, &self.z));
    }
}

// G - Generator of the prime order group on the curve
pub const G: CurvePoint = CurvePoint{ x: u256mod25519{ value: u512 { data: [14507833142362363162, 7578651490590762930, 13881468655802702940, 2407515759118799870, 0, 0, 0, 0] },
                                                   this_is_stupid_why: std::marker::PhantomData },
                                      y: u256mod25519{ value: u512 { data: [7378697629483820632, 7378697629483820646, 7378697629483820646, 7378697629483820646, 0, 0, 0, 0] },
                                                   this_is_stupid_why: std::marker::PhantomData },
                                      z: u256mod25519{ value: u512 { data: [1, 0, 0, 0, 0, 0, 0, 0] },
                                                        this_is_stupid_why: std::marker::PhantomData } 
                                    };

// Comparison, addition, multiplication by scalar etc..
mod curve_point_ops;

// Sqare root modulo 2^255 - 19
pub mod sqrt_mod_25519;

impl std::fmt::Display for CurvePoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        return write!(f, "({}, {})", self.get_x(), self.get_y());
    }
}

// Tests
#[cfg(test)]
mod tests {
    use super::super::bignum_u512::u512;
    use std::str::FromStr;
    use super::*;

    #[test]
    fn two_to_255_minus_19() {

        assert_eq!(super::TWO_TO_255_MINUS_19, u512::power_of_2(255) - u512::from(19));
        assert_eq!(super::TWO_TO_255_MINUS_19, u512::from_str("57896044618658097711785492504343953926634992332820282019728792003956564819949").unwrap());
        assert_eq!(super::TWO_TO_255_MINUS_19, u512 { data: [18446744073709551597, 18446744073709551615, 18446744073709551615, 9223372036854775807, 0, 0, 0, 0] });

        // Paste into python:
        // 2**255 - 19 == 18446744073709551597 + (18446744073709551615 * 2**64) + (18446744073709551615 * 2**128) + (9223372036854775807 * 2**192)
    }

    #[test]
    fn prime_group_order() {

        assert_eq!(super::PRIME_GROUP_ORDER, u512::from_str("7237005577332262213973186563042994240857116359379907606001950938285454250989").unwrap());
        assert_eq!(super::PRIME_GROUP_ORDER, u512 { data: [6346243789798364141, 1503914060200516822, 0, 1152921504606846976, 0, 0, 0, 0] });

        // Paste into python:
        // 2**252 + 27742317777372353535851937790883648493 == 6346243789798364141 + (1503914060200516822 * 2**64) + (0 * 2**128) + (1152921504606846976 * 2**192)
    }

    #[test]
    fn curve_group_order() {

        assert_eq!(super::CURVE_GROUP_ORDER, u512::from(8) * super::PRIME_GROUP_ORDER);
        assert_eq!(super::CURVE_GROUP_ORDER, super::PRIME_GROUP_ORDER << 3);
        assert_eq!(super::CURVE_GROUP_ORDER, u512::from_str("57896044618658097711785492504343953926856930875039260848015607506283634007912").unwrap());
        assert_eq!(super::CURVE_GROUP_ORDER, u512 { data: [13876462170967809896, 12031312481604134578, 0, 9223372036854775808, 0, 0, 0, 0] });

        // Paste into python:
        // 8 * (2**252 + 27742317777372353535851937790883648493) == 13876462170967809896 + (12031312481604134578 * 2**64) + (0 * 2**128) + (9223372036854775808 * 2**192)
    }

    #[test]
    fn curve_d_constant() {
        let d_constant: u256mod25519 = u256mod25519::from(-121665) / u256mod25519::from(121666);
        println!("{}", d_constant.to_u512());
        assert_eq!(CURVE_D_CONSTANT, d_constant);
    }

    #[test]
    fn identity() {
        let identity = CurvePoint::identity();
        assert_eq!(identity.x.to_u512(), u512::zero());
        assert_eq!(identity.y.to_u512(), u512::one());

        assert!(CurvePoint::is_on_curve(&identity.x, &identity.y, &identity.z));

        assert_eq!(&identity + &identity, identity);
        assert_eq!(&identity + &G, G);
        assert_eq!(&G + &identity, G);
    }

    #[test]
    fn prime_generator_g_point() {
        let prime_group_generator: CurvePoint = CurvePoint::from_y_coordinate(u256mod25519::from(4) / u256mod25519::from(5)).unwrap();
        assert_eq!(G, prime_group_generator);
    }

    #[test]
    fn prime_order_times_g_is_identity() {
        assert_eq!(PRIME_GROUP_ORDER * &G, CurvePoint::identity());
    }

    #[test]
    fn curve_order_times_g_is_identity() {
        assert_eq!(CURVE_GROUP_ORDER * &G, CurvePoint::identity());
    }
}